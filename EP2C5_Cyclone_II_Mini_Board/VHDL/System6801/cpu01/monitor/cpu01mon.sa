**===========================================================================**
**
**  D E B U G G E R    CPU01 Debug Monitor
**
**  www.OpenCores.Org - August 2003
**  This software adheres to the GNU public license  
**
** File name      : cpu01mon.sa
**
** Purpose        : Implements a built-in Debug monitor
**                  for the System6801 compatible CPU core
**
** Author         : Michael L. Hasenfratz Sr.
**
**===========================================================================**
**
** Revision History:
**
** Date:		Revision	Author
**===========================================================================**
** 12 Oct 2003		0.1		Michael L. Hasenfratz Sr.
**
 NAM CPU01MON
 TTL Sunday, October 12, 2003 (mlh) DEBUG MONITOR FOR System6801
 SPC 1
*
*    This is a debug monitor for use with
*    the OpenCore System6801 CPU 
*    Or MOTOROLA MC6800 MICROPROCESSORS
*
 SPC 1
*
*    PROGRAM START ADDRESS
*
ROMSTR EQU $F800 . ROM START ADDRESS
RAMSTR EQU $0080 . RAM START ADDRESS
RAMEND EQU $0100 . RAM END ADDRESS
IO$STR EQU $0000 . INTERNAL REGISTERS
 SPC 1
*
*      wb_acia (ACIA) SERIAL PORT ADDRESS DEFINITION
*
ACIA$S EQU IO$STR+$10 . Start of the ACIA
ACCTRL EQU ACIA$S+0 . ACIA CONTROL
ACSTAT EQU ACIA$S+0 . ACIA STATUS
RXDATA EQU ACIA$S+1 . RECEIVE DATA PORT
TXDATA EQU ACIA$S+1 . TRANSMIT DATA PORT
RDRF   EQU %00000001 . RCV DATA REG FULL
TDRE   EQU %00000010 . TX DATA REG EMPTY
 SPC 1
*
*    SOME ASCII CHARACTER DEFINITIONS
*
CR EQU $0D . <CR>
LF EQU $0A . <LF>
SPACE EQU $20 . <SPACE>
BELL EQU $07 . <BELL/BEEP>
 SPC 1
*
*     RAM LOCATIONS REQUIRED 
*
       ORG RAMSTR
VARSTR EQU *
USTACK RMB 2 . USER'S STACK POINTER
 SPC 1
*
*      VECTOR BUFFER
*
VECBUF EQU *
IRQSCI RMB 2 . 'SCI' VECTOR
IRQTOF RMB 2 . 'TOF' VECTOR
IRQOCF RMB 2 . 'OCF' VECTOR
IRQICF RMB 2 . 'ICF' VECTOR
IRQ$VC RMB 2 . IRQ VECTOR
SWI$VC RMB 2 . SWI #1 VECTOR
NMI$VC RMB 2 . NMI VECTOR
 SPC 1
*
*      MISC. REGISTERS
*
ADDRES RMB 2 . ADDRESS TEMPORARY STORAGE
AECHO RMB 1 . ECHO FLAG
BYTECT RMB 1 . BYTE COUNT (LOADER)
CHKSUM RMB 1 . CHECK-SUM (LOADER)
IRQFLG RMB 1 . IRQ FLAG 0=STOP IRQ
VFLAG RMB 1 . VALUE FLAG 0=NO ENTRY
VALUE RMB 2 . BINARY VALUE ENTERED
BRKPTS RMB 4*4 . 4 BREAK-POINTS MAY BE SET
OFFSET RMB 2 . OFFSET TO BE ADDED TO ADDRESSES
DB$STK RMB 2 . DEBUG STACK
BEGADR RMB 2 . BEGIN ADDRESS
ENDADR RMB 2 . END ADDRESS
TMP$00 RMB 2 . SOME TEMPORARY STORAGE
TMP$01 RMB 2
TMP$02 RMB 2
TMP$03 RMB 2
VAREND EQU *
 SPC 1
U$STK EQU (VAREND+((RAMEND-VAREND)/2))-1 . USER'S STACK
STACK EQU RAMEND-1
 SPC 1
*
*    ROM START (JUMP TABLE)
*
 ORG ROMSTR
 JMP INCH . INPUT 1 CHAR FROM CONSOLE (W/PARITY)
 JMP INCHNP . INPUT 1 CHAR FROM CONSOLE (WO/PARITY)
 JMP OUTCH . OUTPUT 1 CHAR TO CONSOLE
 JMP PDATA . PRINT <CR>,<LF>,<NULLS> & STRING (TO EOT)
 JMP PDATA1 . PRINT STRING (TO EOT)
 JMP PCRLF . PRINT <CR>,<LF>,<NULLS>
 JMP GO$SB2 . RE-ENTER MONITOR (WO/INITIALIZATION)
 JMP BEGEND . GET BEGIN/END ADDRESSES
 JMP OUT2HS . PRINT 2 HEX CHARS & <SP>
 JMP OUT4HS . PRINT 4 HEX CHARS & <SP>
 SPC 1
*
*   (wb_acia) ACIA INITIALIZATION VALUE
*
ACINIT FCB %00010101 . NO RCV IRQ, NO XMIT IRQ, 8 BIT, NO PARITY, 1 STOP, 9600 BAUD (CNTL)
 SPC 1
*
*    S T R I N G S   A N D   T H I N G S
*
HEADER FCC /CPU01MON Ver. 2.2/
 FCB 4
PRMT FCB 0,0,0,0,'>,4
INVAL FCC / - INV/
 FCB 4
BEGMSG FCC /BEG ADDR - /
 FCB 4
ENDMSG FCC /END ADDR - /
 FCB 4
MEMERR FCB $13 . READER OFF
 FCC / - NO CHANGE/
WHAT FCB BELL,4
CMPMSG FCC /NO COMPARE @/
 FCB BELL,4
CHKERR FCB $13 . READER OFF
 FCC / - CHK SUM ERR/
 FCB BELL,4
LOADER FCB $13 . READER OFF
 FCC / - LOAD ERR/
 FCB BELL,4
BRKSTG FCC /   BREAK - POINTS/
CRLF FCB CR,LF,0,0,0,0,4
RTSSTR FCC /RETURN/
 FCB 4
REGSTR FCC /REG/
 FCB 4
IRQSTR FCC /IRQ/
 FCB 4
SWISTR FCC /SWI/
 FCB 4
NMISTR FCC /NMI/
 FCB 4
BRKSTR FCC /BRK PNT/
 FCB 4
DSPSTR FCC / - CC=/ . REGISTER DUMP STRING
 FCB 4
 FCC /B=/
 FCB 4
 FCC /A=/
 FCB 4
 FCC /X=/
 FCB 4
 FCC /PC=/
 FCB 4
 FCC /S=/
 FCB 4
 SPC 1
*
*    R E S T A R T   E N T R Y   P O I N T
*
COLD$ LDS #STACK . SET THE STACK
 SPC 1
*
*       SET UP USERS STACK
*
 LDX #U$STK . POINT AT THE USER'S STACK
 STX USTACK . SET USER'S STACK
 JSR IOSET . INIT THE PORTS
 SPC 1
*
*    RESET THE VECTORS
*
 LDX #VECTBL . POINT AT THE TABLE
 STX TMP$00 . SAVE THE SOURCE
 LDX #VECBUF . POINT AT THE BUFFER
 STX TMP$01 . SAVE THE DESTINATION
 LDAB #2*7 . 14 BYTES TO MOVE
VCTLP0 LDX TMP$00 . GET THE POINTER
 LDAA 0,X . GET A BYTE
 INX
 STX TMP$00
 LDX TMP$01 . GET THE DESTINATION
 STAA 0,X
 INX
 STX TMP$01
 DECB
 BNE VCTLP0 . LOOP UNTIL FULL
 SPC 1
*
*    CLEAR THE BREAK POINT TABLE
*
 LDX #BRKPTS . POINT AT THE TABLE
 LDAB #4*4
C$BRK CLR 0,X
 INX
 DECB
 BNE C$BRK
 LDAA #1 . SET THE IRQ BIT
 STAA IRQFLG . CLR THE IRQ FLAG
 CLR OFFSET . RESET THE ADDRESS OFFSET
 CLR OFFSET+1
 SPC 1
*
*    PREPARE TO TALK TO THE USER
*
 LDX #HEADER . SEND SIGN-ON MESSAGE
 JSR PDATA
 SPC 1
*
*    CLEAR THE USER'S STACK
*
 LDX USTACK
 INX
 LDAA #7
CL$STK CLR 0,X . CLEAR THIS BYTE
 INX
 DECA
 BNE CL$STK
 LDS USTACK . POINT AT USER'S STACK
 SPC 1
*
*    W A R M   S T A R T   E N T R Y   P O I N T
*
WARM$ STS USTACK . SAVE THE USER'S STACK
 SPC 1
*
*     H O T   S T A R T   E N T R Y   P O I N T
*
MON$ LDS #STACK . RESET MONITOR STACK
 LDX #PRMT . SEND PROMPT TO USER
 JSR PDATA
 CLR AECHO . RESET THE ECHO FLAG
 LDAB IRQFLG . SEE IF WE SHOULD SET/RESET IRQ BIT
 ANDB #1 . ISOLATE THE BIT
 ASLB
 ASLB
 ASLB
 ASLB . PUT THE BIT IN IT'S PLACE
 TPA . GET THE CC'S
 ANDA #%11101111 . ISOLATE THE IRQ BIT
 ABA . ADD THE BIT
 TAP . RESTORE THE CC'S
 LDX #CMDTBL . POINT AT TABLE OF COMMANDS
 BSR GETCMD
 BCS WHATER
 LDX 1,X . DO THE COMMAND
 JSR 0,X
 BRA MON$
 SPC 1
*
*   SEND A 'WHAT' TO USER
*
WHATER LDX #WHAT
 JSR PDATA1
 JMP MON$
 SPC 1
*
*    GET USER'S REQUEST
*
GETCMD STX TMP$03 . SAVE TABLE ADDRESS
CMDLOP LDX #0 . ZERO OUT VALUE
 STX VALUE
 CLR VFLAG
CMDLP0 JSR INCHNP . GET A CHAR. FROM THE USER
 JSR CHKHEX . IS IT A HEX CHAR
 BCS CHKCM0 . CHECK FOR COMMAND
 JSR ADDHEX . ADD TO 'VALUE' A HEX NUMBER
 BRA CMDLP0 . RETURN TO LOOP
 SPC 1
*
*     CHECK FOR COMMAND
*
CHKCMD JSR INCHNP . GET A CHAR.
 STX TMP$03 . SAVE THE POINTER
CHKCM0 LDX TMP$03 . POINT AT TABLE OF LEGAL COMMANDS
 TST 0,X . SEE IF DUMMY TABLE
 BEQ CHKDUM . JUST EXIT
CHKCL0 CMPA 0,X . THIS COMMAND?
 BEQ CMD$DO . YES
 INX . MOVE TO NEXT COMMAND
 INX
 INX
 TST 0,X . END OF TABLE?
 BNE CHKCL0 . NO KEEP GOING
CHKDUM SEC . SET FOR ILLEGAL COMMAND
 RTS
 SPC 1
*
*    GOOD COMMAND
*
CMD$DO CLC . SET FOR LEGAL COMMAND RECEIVED
 RTS
 SPC 1
*
*    TABLE OF LEGAL COMMANDS
*
CMDTBL FCB '/ . EXAMINE MEMORY
 FDB EXAMIN
 FCB '; . SUB-PROGRAM ROUTINE
 FDB SUBPRG
 FCB CR . DUMMY COMMAND (IGNORE)
 FDB CHKDUM
 FCB 0 . END OF TABLE
 SPC 1
*
*    CHECK CHARACTER IN 'A' FOR HEX
*
CHKHEX CMPA #'0 . SEE IF NUMERIC
 BLT CHKHNO
 CMPA #'9
 BLS CISHEX
 CMPA #'A . ALFA?
 BLT CHKHNO
 CMPA #'F 
 BLS CISHEX
CHKHNO SEC
 RTS
 SPC 1
*
CISHEX SUBA #'0
 CMPA #9 . DONE?
 BLS CHKHDN
 SUBA #7 . ALFA
CHKHDN CLC
 RTS
 SPC 1
*
*      ADD A HEX NUMBER IN 'A' TO 'VALUE'
*
ADDHEX ASL VALUE+1 . MULTIPLY VALUE BY 16
 ROL VALUE
 ASL VALUE+1
 ROL VALUE
 ASL VALUE+1
 ROL VALUE
 ASL VALUE+1
 ROL VALUE
 ADDA VALUE+1
 STAA VALUE+1
 BCC ADDONE
 INC VALUE
ADDONE LDAA #1 . SET FLAG
 STAA VFLAG
 RTS
 SPC 1
*
*    INPUT 1 CHARACTER FROM ACIA WO/PARITY
*
INCHNP BSR INCH . GET A CHAR.
 ANDA #$7F . REMOVE THE PARITY BIT
 RTS
 SPC 1
*
*    INPUT 1 CHARACTER FROM ACIA W/PARITY
*
INCH LDAA ACSTAT . CHECK FOR RDRF
 BITA #RDRF
 BEQ INCH
 LDAA RXDATA . GET THE CHAR.
 TST AECHO . SHOULD WE ECHO THE CHAR.
 BNE OUTRTS
 SPC 1
*
*    OUTPUT 1 CHARACTER
*
OUTCH PSHB . SAVE B REG
OUT$LP LDAB ACSTAT . WAIT FOR TDRE
 BITB #TDRE
 BEQ OUT$LP
 STAA TXDATA . OUTPUT THE CHAR.
 PULB . RESTORE THE REGS
OUTRTS RTS
 SPC 1
*
*     PRINT <CR><LF>'STRING'
*
PDATA BSR PCRLF . PRINT A <CR><LF>
PDATA1 LDAA 0,X . GET A CHAR.
 INX . MOVE TO NEXT CHAR.
 CMPA #4 . EOT?
 BEQ P$DONE . YES
 BSR OUTCH
 BRA PDATA1
P$DONE RTS
 SPC 1
*
*   PRINT A <CR><LF>
*
PCRLF STX TMP$02 . SAVE THE XREG
 LDX #CRLF
 BSR PDATA1 . SEND THIS STRING
 LDX TMP$02 . RESTORE THE XREG
 RTS
 SPC 1
*
*    DISPLAY MPU REGISTERS
*
DSPRTS LDX #RTSSTR
 BRA DSPRTN
 SPC 1
*
DSPREG LDX #REGSTR
 BRA DSPRTN
 SPC 1
*
DSPSWI LDX #SWISTR
 BRA DSPRTN
 SPC 1
*
DSPIRQ LDX #IRQSTR
 BRA DSPRTN
 SPC 1
*
DSPBRK LDX #BRKSTR
 BRA DSPRTN
 SPC 1
*
DSPNMI LDX #NMISTR
 BRA DSPRTN
 SPC 1
*
*    DISPLAY THE REGISTERS
*
DSPRTN JSR PDATA . PRINT THE STRING
 LDX #DSPSTR
 STX TMP$01
 LDX USTACK . POINT AT THE USER'S STACK
 INX
 LDAB #3 . PRINT THE 3, 2 BYTE REGISTERS
 BSR PRNT2B
 LDAB #2 . PRINT THE 2, 4 BYTE REGISTERS
 BSR PRNT4B
 LDX #USTACK . POINT AT THE ADDRESS
 LDAB #1 . PRINT THE STACK ADDRESS
 SPC 1
*
*    PRINT 4 BYTE REGISTER
*
PRNT4B STX TMP$00
 LDX TMP$01
 JSR PDATA1 . PRINT THE STRING
 STX TMP$01 . SWAP THE REGISTERS
 LDX TMP$00
 JSR OUT4HS . PRINT VALUE
 DECB
 BNE PRNT4B
 RTS
 SPC 1
*
*    PRINT 2 BYTE REGISTER
*
PRNT2B STX TMP$00
 LDX TMP$01
 JSR PDATA1 . PRINT THE STRING
 STX TMP$01 . SWAP THE REGISTERS
 LDX TMP$00
 JSR OUT2HS . PRINT THE DATA
 DECB
 BNE PRNT2B
 RTS
 SPC 1
*
*     OUTPUT HEX CHARS W/SPACE
*
OUT4HS BSR OUT2H
OUT2HS BSR OUT2H
OUTS LDAA #SPACE . OUTPUT A SPACE
 JMP OUTCH
 SPC 1
*
*     OUTPUT 2 HEX CHAR.S
*
OUT2H LDAA 0,X . GET THE CHAR.
 LSRA . MOVE MSN TO LSN
 LSRA
 LSRA
 LSRA
 BSR HEX$IT
 LDAA 0,X . GET CHAR. AGAIN
 INX
 SPC 1
*
*     CONVERT 'A' REG TO BINARY (LSN) TO ASCII
*
HEX$IT ANDA #%1111 . SAVE ONLY LSN
 ORAA #'0 . MAKE ASCII
 CMPA #'9
 BLS OUTHX . OUTPUT THE CHAR
 ADDA #7 . MAKE ALFA
OUTHX JMP OUTCH
 SPC 1
*
*     INPUT 4 HEX CHARS
*
IN4HEX BSR IN2HEX
 BCS NO$IHX . WAS'NT HEX
 PSHA . SAVE THE MSB
 PSHA
 BSR IN2HEX
 TSX . POINT AT RESULT
 STAA 1,X . SAVE THE LSB
 LDX 0,X . GET THE RESULT
 INS . FIX THE STACK
 INS
 RTS
 SPC 1
*
*    INPUT 2 HEX CHARS
*
IN2HEX BSR INHEX . GET THE MSN
 BCS NO$IHX . NOT HEX
 ASLA . PUT IT IN THE MS NIBBLE
 ASLA
 ASLA
 ASLA
 STAA TMP$00 . SAVE IT
 BSR INHEX . GET THE LSN
 BCS NO$IHX . NOT HEX
 ADDA TMP$00 . ADD NIBBLES
 STAA TMP$00 . SAVE IT
 ADDA CHKSUM . ADD TO CHECK SUM
 STAA CHKSUM
 LDAA TMP$00 . GET THE CHAR.
 CLC
 RTS
 SPC 1
*
*     INPUT 1 HEX CHAR. IN A
*
INHEX JSR INCHNP . GET A BYTE FROM USER
 JMP CHKHEX . CHECK AND CONVERT
 SPC 1
*
*     NOT HEX
*
NO$IHY INS . FIX THE STACK
NO$IHX SEC
 RTS
 SPC 1
*
*     I/O INITIALIZATION
*
IOSET LDAA #%00000011 . TRASH THE ACIA
 STAA ACCTRL
 LDAA ACINIT . GET THE INIT VALUE
 STAA ACCTRL
 RTS
 SPC 1
*
*     EXAMINE MEMORY
*
EXAMIN LDAB VALUE . GET THE ADDRESS
 LDAA VALUE+1
 ADDA OFFSET+1 . ADD THE OFFSET
 ADCB OFFSET
 STAB ADDRES . SAVE THE VALUE
 STAA ADDRES+1
 SPC 1  
*
EX$LP0 JSR PCRLF
 LDX #ADDRES . POINT AT THE DATA ADDRESS
 JSR OUT4HS . PRINT THE ADDRESS
EX$LP1 LDX ADDRES . POINT AT THE DATA
 JSR OUT2HS . PRINT THE DATA
 SPC 1
*
*     WAIT FOR COMMAND
*
EX$LP2 LDX #EXMTBL . POINT AT TABLE OF COMMANDS
 JSR GETCMD . GET A VALUE AND/OR A COMMAND
 BCC EX$JMP . LEGAL?
 JMP WHATER . NO!
 SPC 1
*
*    DO TO IT
*
EX$JMP LDX 1,X . GET TASK ADDRESS
 JMP 0,X . DO THE REQUEST
 SPC 1
*
*     COMMAND TABLE
*
EXMTBL FCB '/ . DISPLAY SAME ADDRESS
 FDB EX$SAM
 FCB SPACE . DISPLAY NEXT ADDRESS
 FDB EX$NXT
 FCB LF . DISPLAY NEXT ADDRESS (ALT. METHOD)
 FDB EX$NXT
 FCB '^ . DISPLAY LAST ADDRESS
 FDB EX$BAK
 FCB CR . RETURN TO MONITOR
 FDB EX$RTS
 FCB '; . CALCULATE OFFSET
 FDB EX$OFS
 FCB 0
 SPC 1
*
*    DISPLAY NEXT ADDRESS
*
EX$NXT BSR EX$STR . TRY TO STORE VALUE
 INX
 STX ADDRES
 BRA EX$LP0
 SPC 1
*
*    DISPLAY LAST ADDRESS
*
EX$BAK BSR EX$STR . TRY TO STORE THE CHAR.
 DEX
 STX ADDRES . SAVE THE NEW VALUE
 BRA EX$LP0
 SPC 1
*
*    DISPLAY SAME ADDRESS
*
EX$SAM BSR EX$STR . TRY TO STORE THE CHAR.
 BRA EX$LP1 . DON'T MOVE TO NEW LINE
 SPC 1
*
*   STORE THE VALUE
*
EX$STR LDX ADDRES . POINT AT MEMORY
 TST VFLAG . SHOULD WE STORE IT?
 BEQ EXNSTR . NO
 LDAA VALUE+1 . GET THE VALUE
 STAA 0,X . STORE IT
 CMPA 0,X . SEE IF GOOD MEMORY
 BNE EX$BEL . NO CHANGE
EXNSTR RTS
 SPC 1
*
*   NO CHANGE IN MEMORY
*
EX$BEL STX TMP$00 . SAVE ADDRESS
 LDX #MEMERR . MEMORY ERROR
 JSR PDATA1
 LDX TMP$00 . RESTORE ADDRESS
 RTS
 SPC 1
*
*    RETURN TO THE MONITOR
*
EX$RTS BSR EX$STR . TRY TO STORE THE VALUE
 RTS . RETURN TO THE MONITOR
 SPC 1
*
*    CALCULATE OFFSET TO ADDRESS
*
EX$OFS JSR INCHNP . GET THE NEXT CHAR.
 CMPA #'O . OFFSET?
 BNE EX$OEX . NO
 JSR OUTS . SEND A SPACE
 LDAB VALUE . GET THE OFFSET VALUE
 LDAA VALUE+1
 SUBA ADDRES+1 . SUBTRACT THE CURRENT ADDRESS
 SBCB ADDRES
 SUBA #1 . SAME ADDRES =-1
 SBCB #0
 PSHA . SAVE IT ON THE STACK
 TSX . POINT AT LONG VALUE
 CMPB #0 . IF A <> $FF OR $00 THEN ILLEGAL BRANCH
 BNE EX$SHX . MIGHT STILL BE GOOD
 BITA #$80 . MSB MUST BE 0
 BEQ EX$SHT . GOOD BRANCH
 BRA EX$LNG . INVALID
EX$SHX CMPB #$FF
 BNE EX$LNG . GOOD SHORT
 BITA #$80 . MSB MUST BE 1
 BNE EX$SHT . GOOD BRANCH
EX$LNG LDX #INVAL . INVALID BRANCH
 JSR PDATA1
 BRA EX$FST . GO FIX THE STACK
EX$SHT JSR OUT2HS . OUTPUT (SHORT) VALUE
EX$FST INS . FIX THE STACK
EX$OEX JMP EX$LP0
 SPC 1
*
*    SUB-COMMANDS
*
SUBPRG LDX #SUBTBL . POINT AT TABLE OF SUB-COMMANDS
 JSR CHKCMD . GET THE REQUEST
 BCC SB$JMP . LEGAL?
 JMP WHATER . ILLEGAL COMMAND
 SPC 1
*
*    GO DO IT
*
SB$JMP LDX 1,X . GET THE TASK
 JMP 0,X . GO TO IT.
 SPC 1
*
*     TABLE OF SUB-COMANDS
*
SUBTBL FCB 'R . DISPLAY REGISTERS
 FDB DSPREG
 FCB 'G . GO TO USER'S PROGRAM
 FDB GO$USR
 FCB 'S . GO TO USER'S SUB-ROUTINE
 FDB GO$SUB
 FCB 'V . SET/DISPLAY BREAK-POINTS
 FDB SBKRTN
 FCB 'U . CLEAR BREAK-POINTS
 FDB CBKRTN
 FCB 'D . DISPLAY MEMORY
 FDB DSPMEM
 FCB 'P . CONTINUE USER'S PROGRAM
 FDB GO$CON
 FCB 'F . FILL MEMORY WITH CHAR.
 FDB FILMEM
 FCB 'C . COMPARE MEMORY WITH CHAR.
 FDB CMPMEM
 FCB 'M . MOVE MEMORY
 FDB MOVMEM
 FCB 'I . SET/RESET/PRINT IRQ FLAG
 FDB IRQ$RT
 FCB 'O . SET OR RESET OFFSET
 FDB OFS$RT
 FCB 'L . 'S1' RECORD LOADER
 FDB LOAD
 FCB 0
 SPC 1
*
*     GO TO USER PROGRAM
*
GO$USR TST VFLAG . SEE IF VALID REQUEST
 BEQ GO$BAD . CAN'T DO THAT
 LDS USTACK . GET USER'S STACK
 TSX
 LDAB VALUE . GET NEW ADDRESS
 LDAA VALUE+1
 STAB 5,X . SET PC COUNTER
 STAA 6,X
GOU$DO JSR SETBRK . GO SET THE BREAK POINTS
 RTI
 SPC 1
*
*     GO TO USER'S SUB-ROUTINE
*
GO$SUB TST VFLAG . SEE IF ADDRESS SET
 BEQ GO$BAD . CAN'T
 LDS USTACK . GET USER'S STACK
 SPC 1
*
*    MOVE STACK DOWN 2 PLACES
*
 DES . MAKE ROOM ON STACK FOR ADDRESS OF PART #2
 DES
 TSX . POINT AT DATA ON STACK
 LDAB #7 . 7 BYTES TO MOVE
GO$SBL LDAA 2,X . GET A BYTE
 STAA 0,X
 INX
 DECB 
 BNE GO$SBL
 LDX #GO$SB2 . POINT AT PART #2
 STX TMP$00
 TSX
 LDAB TMP$00 . POINT AT PART #2 (MSB)
 LDAA TMP$00+1 . (LSB)
 STAB 7,X . SET 'RETURN' ADDRESS
 STAA 8,X
 LDAB VALUE . USER'S ADDRESS
 LDAA VALUE+1
 STAB 5,X . SET 'PC'
 STAA 6,X
 BRA GOU$DO
 SPC 1
*
*     SUB-ROUTINE PART #2
*
GO$SB2 SWI . CAUSE A BREAKPOINT CHECK
SUB$RK EQU *
 SPC 1
*
*    PART THREE OF SUB-ROUTINE CALL
*
GO$SB3 STS USTACK . RESTORE USER'S STACK
 TSX
 LDS #STACK . GET THE DEBUG STACK
 LDAB VALUE
 LDAA VALUE+1
 STAB 5,X . PUT CALLED ADDRESS IN PC
 STAA 6,X
 JSR DSPRTS
 JSR CLRBRK . GO RESET THE BREAK POINTS
 JMP MON$
 SPC 1
*
*      CAN'T DO IT
*
GO$BAD LDS #STACK . RESET DEBUG STACK
 JSR WHATER . CANT DO IT
 JMP MON$
 SPC 1
*
*     CONTINUE WITH USER'S PROGRAM
*
GO$CON LDX USTACK
 LDX 6,X . GET USER'S PC
 INC VFLAG . SET THE FLAG
 STX VALUE . SET PC
 JMP GO$USR . GO TO USER'S PROGRAM
 SPC 1
*
*     SET/DISPLAY THE OFFSET
*
OFS$RT TST VFLAG . SET OR DISPLAY
 BEQ OFS$DS . DISPLAY
 LDX VALUE . GET THE NEW OFFSET
 STX OFFSET
 RTS
 SPC 1
*
OFS$DS LDAA #'= . SEND AN EQUAL SIGN
 JSR OUTCH
 LDX #OFFSET . POINT AT THE OFFSET VALUE
 JMP OUT4HS
 SPC 1
*
*      SET/DISPLAY BREAK-POINTS
*
SBKRTN TST VFLAG . SEE IF DISPLAY OR SET
 BEQ BK$DSP
 SPC 1
*
*      SET A BREAK POINT
*
 LDX #BRKPTS . FIND EMPTY BREAK POINT AREA
 LDAB #3 . 3 PLACES TO CHECK
BRK$L0 LDAA 0,X . SEE IF EMPTY
 ORAA 1,X
 BEQ BRK$00
 INX . MOVE TO NEXT PLACE
 INX
 INX
 INX
 DECB
 BNE BRK$L0
 SPC 1
*
BRK$00 LDAB VALUE . POINT AT ADDRESS OF BREAK POINT
 LDAA VALUE+1
 STAB 0,X . SAVE THIS AREA
 STAA 1,X
 CLR 2,X
 CLR 3,X
 RTS
 SPC 1
*
*     DISPLAY THE BREAK POINTS
*
BK$DSP LDX #BRKSTG . SEND THE STRING MESSAGE
 JSR PDATA
 LDX #BRKPTS . POINT AT THE BREAK POINT ADDRESSES
 LDAB #4 . 4 TO DISPLAY
 SPC 1
*
BK$DL0 JSR OUT4HS . PRINT THE ADDRESS
 INX
 INX
 DECB
 BNE BK$DL0
 RTS
 SPC 1
*
*     CLEAR BREAK POINTS
*
CBKRTN TST VFLAG . DO ALL OR ONE?
 BEQ CBK$AL . ALL
 SPC 1
*
*     SEARCH FOR BREAK POINT ADDRESS
*
 LDX #BRKPTS . POINT AT THE TABLE
 LDAB #4 . 4 PLACES TO CHECK
 STAA TMP$00
 LDAB VALUE 
 LDAA VALUE+1
CBK$L0 CMPB 0,X . CHECK MSB
 BNE CBK$NX . NOT THIS ONE
 CMPA 1,X . CHECK LSB
 BEQ CBK$CL . CLEAR THIS LOCATION
CBK$NX INX . MOVE TO NEXT LOCATION
 INX
 INX
 INX
 DEC TMP$00 . DECR. COUNTER
 BNE CBK$L0
 RTS
 SPC 1
*
CBK$CL CLR 0,X . CLEAR THIS LOCATION
 CLR 1,X
 CLR 2,X
 CLR 3,X
 RTS
 SPC 1
*
*     CLEAR ALL BREAK POINTS
*
CBK$AL LDX #BRKPTS . POINT AT TABLE
 LDAB #4*4 . 4 SETS
CBK$L1 CLR 0,X
 INX
 DECB
 BNE CBK$L1
 RTS
 SPC 1
*
*       SET BREAK POINTS IN MEMORY
*
SETBRK LDX #BRKPTS . POINT AT BREAK POINT TABLE
 LDAB #4
SET$B0 STX TMP$03 . SAVE THE POINTER
 LDX 0,X . GET ADDRESS
 BEQ SET$NX . DO NEXT
 LDAA 0,X . GET THE BYTE
 LDX TMP$03 . RESTORE THE POINTER
 STAA 2,X . SAVE IT
 LDX 0,X . POINT AT ADDRESS AGAIN
 LDAA #$3F . SET BREAK POINT IN THIS LOCATION
 STAA 0,X
SET$NX LDX TMP$03 . MOVE TO NEXT LOCATION
 INX
 INX
 INX
 INX
 DECB
 BNE SET$B0
 RTS
 SPC 1
*
*     RESTORE THE BREAK POINT VALUES
*
CLRBRK LDX #BRKPTS . POINT AT TABLE
 LDAB #4
CLR$B0 STX TMP$03 . SAVE THE POINTER
 LDAA 2,X . GET THE OPCODE
 LDX 0,X . POINT AT THE OPCODE ADDRESS
 BEQ CLR$NY 
 STAA 0,X . RESTORE IT
CLR$NY LDX TMP$03 . MOVE TO NEXT LOCATION
 INX
 INX
 INX
 INX
 DECB
 BNE CLR$B0
 RTS
 SPC 1
*
*     GET BEGIN AND END ADDRESSES
*
BEGEND LDX #BEGMSG . SEND THE QUESTION
 JSR BEGVAL . GET A VALUE AND A CHAR.
 BNE BEGEXT . NO
 STX BEGADR . SAVE THE VALUE
 LDX #ENDMSG . SEND THE QUESTION
 BSR BEGVAL . GET THE VALUE
 BNE BEGEXT . NO
 STX ENDADR . SAVE THE 'END' ADDRESS
 CLC
 RTS
 SPC 1
*
*   SEND STRING AND GET THE VALUE
*
BEGVAL JSR PDATA . SEND STRING TO DISPLAY
 LDX #DUMTBL . POINT AT DUMMY TABLE
 JSR GETCMD . GET A VALUE
 LDX VALUE
 CMPA #CR . SEE IF GOOD VALUE
 RTS
 SPC 1
*
*   ERROR EXIT FROM BEGEND ROUTINE
*
BEGEXT SEC
 RTS
 SPC 1
*
*     FILL MEMORY FROM XXXX TO YYYY WITH ZZ
*
FILMEM LDAA VALUE+1 . GET THE FILL VALUE
 PSHA . SAVE IT
 BSR BEGEND . GET THE ADDRESSES
 BCS FIL$EX . FORGET IT
 LDAB OFFSET . ADD THE OFFSET
 LDAA OFFSET+1
 ADDA ENDADR+1 . SET THE FROM ADDRESS
 ADCB ENDADR
 ADDA #1 . SET STOP ADDRESS
 ADCB #0
 STAB ENDADR
 STAA ENDADR+1
 LDAB OFFSET
 LDAA OFFSET+1
 ADDA BEGADR+1 . SET THE TO ADDRESS
 ADCB BEGADR
 STAB BEGADR
 STAA BEGADR+1
 PULA . GET FILL CHAR.
 LDX BEGADR . GET 'FROM' ADDRESS
 SPC 1
*
FIL$L0 STAA 0,X . STORE THE BYTE
 INX
 CPX ENDADR . DONE?
 BNE FIL$L0 . NO
 RTS
 SPC 1
*
FIL$EX PULA . RESTORE THE STACK
 RTS
 SPC 1
*
*     COMPARE MEMORY FROM XXXX TO YYYY WITH ZZ
*
CMPMEM LDAA VALUE+1 . GET THE COMPARE VALUE
 PSHA . SAVE IT
 BSR BEGEND . GET THE ADDRESSES
 BCS CMP$EX . FORGET IT
 LDAB OFFSET . ADD THE OFFSET
 LDAA OFFSET+1
 ADDA ENDADR+1 . SET THE FROM ADDRESS
 ADCB ENDADR
 ADDA #1 . SET STOP ADDRESS
 ADCB #0
 STAB ENDADR
 STAA ENDADR+1
 LDAB OFFSET
 LDAA OFFSET+1
 ADDA BEGADR+1 . SET THE TO ADDRESS
 ADCB BEGADR
 STAB BEGADR
 STAA BEGADR+1
 PULA . GET COMPARE CHAR.
 LDX BEGADR . GET 'FROM' ADDRESS
 SPC 1
*
CMP$L0 LDAB 0,X . GET THE BYTE
 CBA . COMPARE THE BYTES
 BEQ CMP$NX . DATA COMPARED, MOVE ON
 SPC 1
*
*    SEND AN ERROR MESSAGE
*
CMP$ER STX TMP$00 . SAVE THE ADDRESS
 STAB TMP$01 . SAVE IT
 PSHA . SAVE THE COMPARE VALUE
 LDX #CMPMSG . SEND THE MESSAGE
 JSR PDATA 
 LDX #TMP$00 . POINT AT THE ADDRESS
 JSR OUT4HS  . SEND THE ADDRESS
 JSR OUT2HS  . SEND THE BAD DATA
 LDX TMP$00  . GET THE POINTER
 PULA . RESTORE THE COMPARE VALUE
 SPC 1
*
CMP$NX INX . MOVE TO NEXT LOCATION
 CPX ENDADR . DONE?
 BNE CMP$L0 . NO
 RTS
 SPC 1
*
CMP$EX PULA . RESTORE THE STACK
 RTS
 SPC 1
*
*    MOVE DATA FROM XXXX TO YYYY
*
MOVMEM LDX VALUE . GET DESTINATION
 STX TMP$00 SAVE IT
 TST VFLAG . WAS A VALUE ENTERED?
 BEQ MOVEXT . NO
 JSR BEGEND . GET ADDRESSES
 BCS MOVEXT . FORGET IT
 LDX ENDADR
 INX . BUMP ADDRESS FOR COMPARISON
 STX ENDADR
 LDX BEGADR . GET 'FROM' ADDRESS
 SPC 1
*
MOVLP0 LDAA 0,X . GET A BYTE
 INX
 STX BEGADR
 LDX TMP$00 . GET DESTINATION ADDRESS
 STAA 0,X . STORE IT
 INX
 STX TMP$00
 LDX BEGADR . FROM ADDRESS
 CPX ENDADR . DONE?
 BNE MOVLP0 . NO
MOVEXT RTS
 SPC 1
*
*    SET/RESET/PRINT IRQ FLAG
*
IRQ$RT TST VFLAG . SET/RESET OR PRINT
 BEQ PRTIRQ . PRINT IT
 LDAA VALUE+1 . GET THE VALUE
 ANDA #%1 . SAVE THE BIT 0 ONLY
 STAA IRQFLG
 RTS
 SPC 1
*
*    PRINT THE FLAG
*
PRTIRQ LDAA #'= . SEND AN EQUAL SIGN
 JSR OUTCH
 LDX #IRQFLG . POINT AT THE FLAG
 JMP OUT2H
 SPC 1
*
*     CHECK FOR OPERATOR INTERVENTION
*
CKBRK LDAA ACSTAT . CHECK FOR CHARACTER
 BITA #RDRF . RDRF TRUE?
 BEQ CKBRKN . NOT YET
 STAA AECHO . NO ECHO
 JSR INCHNP . GET THE CHARACTER
CKBRKL CMPA #$17 . <CNTRL-W>
 BNE CKBRKN . NO
 SPC 1
*
*    WAIT FOR ANOTHER CHARACTER
*
CKBKL JSR INCHNP . WAIT FOR ANOTHER CHARACTER
 CMPA #$18 . <CNTRL-X>
 BNE CKBRKL . DONT ABORT YET
 SEC
 RTS
 SPC 1
*
*    NO INTERVENTION
*
CKBRKN CLR AECHO . CLEAR THE ECHO FLAG
 RTS
 SPC 1
*
*    DISPLAY MEMORY LOCATIONS
*
DSPMEM JSR BEGEND . GET THE BEG-END ADDRESSES
 BCC DMP$00 . OK TO DUMP
 JMP DMP$EX . EXIT
 SPC 1
*
*    DUMP THE MEMORY
*
DMP$00 LDAB BEGADR . SET ON EVEN BOUNDRY
 LDAA BEGADR+1
 ANDA #%11110000 . ZERO OUT LSN
 ADDA OFFSET+1 . ADD THE OFFSET
 ADCB OFFSET
 STAB BEGADR
 STAA BEGADR+1
 LDAB ENDADR
 LDAA ENDADR+1
 ORAA #%1111 . END ON EVEN 16
 ADDA OFFSET+1 . ADD THE OFFSET
 ADCB OFFSET
 ADDA #1 . AND ADD 1
 ADCB #0
 STAB ENDADR
 STAA ENDADR+1
 SPC 1
*
*     MAKE ROOM FOR ASCII DATA ON STACK
*
 LDAB #17 . 17 PLACES
DM$PL0 DES
 DECB
 BNE DM$PL0
 SPC 1
*
*     RESET ASCII BUFFER
*
DMP$L0 BSR CKBRK . CHECK FOR USER INTERVENTION
 BCS DMP$BK . EXIT THE PROGRAM
 TSX . POINT AT THE ASCII BUFFER
 STX TMP$00 . RESET THE POINTER
 SPC 1
*
*     OUTPUT MEMORY DATA
*
DMP$L2 LDX #BEGADR . POINT AT DATA ADDRESS
 JSR PCRLF . NEW LINE
 JSR OUT4HS . PRINT ADDRESS
 LDAB #16 . 16 BYTES TO PRINT
 LDX BEGADR . POINT AT THE DATA
 SPC 1
*
DMP$L3 LDAA 0,X . GET THE BYTE
 STX BEGADR
 CMPA #$7F . SEE IF ASCII
 BHI DMP$NA . NOT ASCII
 CMPA #SPACE-1
 BHI DMP$IA . IT IS ASCII
DMP$NA LDAA #'. . SET TO ASCII <.>
DMP$IA LDX TMP$00 . STORE OUT THE CHAR.
 STAA 0,X
 INX
 STX TMP$00
 LDX BEGADR . POINT AT THE DATA AGAIN
 JSR OUT2HS
 DECB
 BNE DMP$L3
 SPC 1
*
*     PRINT ASCII DATA
*
 STX BEGADR . SAVE POINTER
 LDX TMP$00 . SET END OF STRING
 LDAA #4
 STAA 0,X
 TSX . POINT AT DATA
 JSR PDATA1 . PRINT THE STRING
 LDX BEGADR . POINT AT THE DATA
 CPX ENDADR . ARE WE DONE?
 BNE DMP$L0
DMP$BK LDAB #17 . RESTORE THE STACK
DMP$L4 INS
 DECB
 BNE DMP$L4
DMP$EX RTS
 SPC 1
*
*     'S1' RECORD LOADER
*
LOAD LDAA #$11 . SEND DEVICE ON
 STAA AECHO . TURN OFF ECHO
 JSR OUTCH
 SPC 1
*
*     MAKE ROOM ON THE STACK FOR HEADER
*
 LDAB #26
LOD$L0 DES
 DECB
 BNE LOD$L0
 LDAA #4 . SET END OF RECORD
 TSX
 STAA 0,X
 SPC 1
*
*     WAIT FOR RECORD INDICATOR
*
LOAD00 JSR INCHNP . GET A BYTE
 CMPA #'S . IS IT AN 'S'
 BNE LOAD00 . NO
 SPC 1
*
*     WAIT FOR RECORD TYPE
*
 LDX #RECTYP . POINT AT THE RECORD TABLE
 JSR CHKCMD . PROCESS IT
 BCS LOAD00 . NOT A GOOD
 LDX 1,X . GET TASK ADDRESS
 JMP 0,X . JUMP TO IT!
 SPC 1
*
*     RECORD TYPE TABLE
*
RECTYP FCB '0 . HEADER RECORD
 FDB LOADHD
 FCB '1 . DATA RECORD
 FDB LOADRC
 FCB '9 . END OF FILE RECORD
 FDB LOADED 
DUMTBL FCB 0 . TERMINATOR
 SPC 1
*
*      LOAD THE END OF RECORD
*
LOADED JSR LD$SET . GET THE SETUP 
 JSR IN2HEX . GET THE CHECKSUM
 DEC BYTECT . SEE IF LEGAL
 BNE LD$EDE . NOT LEGAL START ADDRESS
 INC CHKSUM
 BNE LD$EDE . ILLEGAL ADDRESS
 STX TMP$00
 LDX USTACK . PUT START ADDRESS IN USER'S PC
 LDAB TMP$00
 LDAA TMP$00+1
 STAB 6,X
 STAA 7,X
LD$EDE LDAA #$13 . TURN OFF READER
 JSR OUTCH
 LDX #0 . DELAY SOME
LOD$L1 DEX
 BNE LOD$L1
 TSX . POINT AT THE HEADER
 JSR PDATA
LOD$EX LDAB #26 . RESTORE THE STACK
LOD$L2 INS
 DECB
 BNE LOD$L2
 JMP MON$
 SPC 1
*
*     LOAD THE HEADER
*
LOADHD JSR LD$SET . SET-UP LOAD
 LDAB BYTECT . CHECK BYTE COUNT
 CMPB #25
 BHI LOAD00 . FORGET IT
 TSX . POINT AT THE STACK
 SPC 1
*
*     READ IN THE HEADER
*
LD$HD0 JSR IN2HEX . GET A CHAR.
 STAA 0,X . STORE IT
 INX
 DEC BYTECT . DONE?
 BNE LD$HD0
 DEX . BACK-UP 1 BYTE
 LDAA #4 . SET E.O.T.
 STAA 0,X
 JMP LOAD00 . CONTINUE THE LOAD
 SPC 1
*
*     LOAD A RECORD
*
LOADRC JSR LD$SET . GET SETUP
LOADR0 JSR IN2HEX . GET A BYTE
 DEC BYTECT . DONE?
 BEQ LD$CHK
 STAA 0,X
 CMPA 0,X
 BNE MEMER$
 INX
 BRA LOADR0
 SPC 1
*
*    ERRORS DURING LOAD
*
MEMER$ LDX #MEMERR . MEMORY NO-CHANGE
 BRA LERR$R
 SPC 1
*
CHKER$ LDX #CHKERR . CHECK-SUM ERROR
LERR$R JSR PDATA
 BRA LOD$EX
 SPC 1
*
*    CHECK FOR PROPER SUM
*
LD$CHK INC CHKSUM
 BNE CHKER$
 JMP LOAD00
 SPC 1
*
*     RECORD SET-UP
*
LD$SET CLR CHKSUM . ZERO CHECK SUM
 JSR IN2HEX . GET BYTE COUNT
 BCS STP$LD . STOP LOADER
 SUBA #2 . REMOVE ADDRESS
 STAA BYTECT . SAVE THE COUNT
 JSR IN4HEX . GET LOAD ADDRESS
 BCS STP$LD
 RTS
 SPC 1
*
*     STOP LOADER
*
STP$LD LDX #LOADER
 JSR PDATA1
 BRA LOD$EX
 SPC 1
*
*     SWI ENTRY POINT
*
SWI1 TSX . GET THE P.C.
 LDX 5,X
 CPX #SUB$RK
 BNE NOT$SB . NOT SUB-ROUTINE CALL
 JMP GO$SB3 . WAS SUB-ROUTINE CALL
 SPC 1
*
*    GET ADDRESS OF SWI
*
NOT$SB TSX
 LDAB #4 . 4 PLACES TO LOOK
 STAB TMP$00
 LDAB 5,X . GET PC
 LDAA 6,X
 SUBA #1 . POINT AT THE 'SWI'
 SBCB #0
 LDX #BRKPTS . POINT AT THE TABLE
 SPC 1
*
*     CHECK TABLE AGAINST PC-1
*
BP$LOP CMPB 0,X . IS THIS THE ADDRESS
 BNE BP$NXT
 CMPA 1,X . LSB
 BEQ BP$FND . YES
BP$NXT INX . MOVE TO NEXT LOCATION
 INX
 INX
 INX
 DEC TMP$00
 BNE BP$LOP
 BRA SWIX . GO TO USER'S 'SWI'
 SPC 1
*
*   IF HERE, WE FOUND A BREAK-POINT
*
BP$FND  TSX
 STAB 5,X . PUT NEW PC ON STACK
 STAA 6,X
 STS USTACK . SAVE USER'S STACK
 LDX #STACK . GET THE DEBUG STACK
 JSR CLRBRK . RESTORE THE BREAK POINTS
 JSR DSPBRK . DISPLAY THE BREAK POINT
 JMP MON$ . GO TO MONITOR ENTRY
 SPC 1
*
*      VECTOR ENTRIES
*
.SWI1 LDAA #'0
 FCB $8C . SKIP 2
.IRQ LDAA #'1
 FCB $8C . SKIP 2
.NMI LDAA #'2
 SPC 1
*
*      DISPLAY THE REGISTERS
*
 STS USTACK . SAVE USER'S STACK
 LDS #STACK . GET MONITOR STACK
 LDX #DSPTBL . POINT AT COMMAND TABLE
 JSR CHKCMD . PROCESS THE COMMAND
 BCS DSPMON . JUST ENTER MONITOR
 LDX 1,X . GET ROUTINE
 JSR 0,X . PRINT THE REGISTERS
DSPMON JMP MON$ . ENTER THE MONITOR
 SPC 1
*
*    DISPLAY TABLE
*
DSPTBL FCB '0 . SWI
 FDB DSPSWI
 FCB '1 . IRQ
 FDB DSPIRQ
 FCB '2 . NMI
 FDB DSPNMI
 FCB 0 . TERMINATOR
 SPC 1
*
*    TABLE OF VECTOR ENTRIES
*
VECTBL FDB .IRQ,.IRQ,.IRQ,.IRQ
 FDB .IRQ,.SWI1,.NMI
*
*    VECTOR ROUTINES
*
IRQ3 LDX #IRQSCI . 'SCI'
 BRA VECT$
IRQ2 LDX #IRQTOF . 'TOF'
 BRA VECT$
IRQ1 LDX #IRQOCF . 'OCF'
 BRA VECT$
IRQ0 LDX #IRQICF . 'ICF'
 BRA VECT$
IRQ LDX #IRQ$VC . 'IRQ'
 BRA VECT$
SWIX LDX #SWI$VC . 'SWI'
 BRA VECT$
NMI LDX #NMI$VC . 'NMI'
 SPC 1
*
*     VECTOR ENTRY
*
VECT$ LDAB 0,X . GET THE VECTOR
 LDAA 1,X
 PSHA . SAVE IT ON THE STACK
 PSHB
 TSX . POINT AT THE STACK DATA
 LDAA 4,X . GET THE AREG
 LDAB 3,X . GET THE BREG
 PSHA . SAVE THE AREG
 LDAA 2,X . GET CC'S
 ORAA #%00010000 . SET THE 'I' BIT
 LDX 5,X . GET XREG
 TAP . SET THE CC'S
 PULA . RESTORE THE AREG
 RTS
 SPC 1
*
*      VECTORS
*
 ORG ROMSTR+$7F0
 FDB IRQ3,IRQ2,IRQ1,IRQ0
 FDB IRQ,SWI1,NMI,COLD$
 SPC 1
 END
